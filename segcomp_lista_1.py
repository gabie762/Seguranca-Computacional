# -*- coding: utf-8 -*-
"""SegComp lista 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ak5YGms91bpGoAmgsXzsnprrXyGumbC_

#Segurança Computacional - Universidade de Brasília | Lista 1 | 2024.2 | Turma 02

##Aluna: Gabriela de Oliveira Henriques | 211055254

Introdução: Esta arquivo tem o intuito de realizar os dois exercícios de criptografia passados em sala de aula - Shift Cipher e Cifra por Transposição.


---

##Exercício 1: Quebrando Shift Cipher

* Elaborar o código para realizar a cifra por deslocamento (dica: validar para cifra de César onde k=3);
* Elaborar o código que quebra a cifra por deslocamento, descodificando através de duas estratégias de ataques à cifra (CipherText-only):
  * por distribuição de frequência;
  * por ataque de força bruta;
  * O resultado será o texto decriptografado e o tamanho da chave de deslocamento k.

### Função de Encriptação (`enc_shift`)

Essa função recebe um texto não criptografado e a chave usada para encriptação. Toda a string é colocada para upper case para auxiliar no processo. Além disso, há uma string vazia onde será colocado o texto criptografado.

Por fim, há um loop que rodará por toda a string do texto original. Nele, a função `ord` do Python transforma o caractere em seu respectivo número ASCII. Após isso, é subtraído o número 65. Isso ocorre pois todo o alfabeto maiúsculo de ASCII se encontra no intervalo dos números 65 até 90.

Subtraindo esse número específico, é possível trabalhar algebricamente com o alfabeto correspondendo dos números de 0 a 25. Após isso, é retirado o módulo do caractere por 26, o que resulta no número da letra encriptografada. Por fim, é adicionado 65 novamente, para corresponder ao novo caracter que é adicionado na lista de `cipher_text`.


A função tem tempo computacional O(n^2).
"""

def enc_shift(plain_text, key):
  """
  ### A função transforma todos os caracteres do texto para letras maiusculas. Apos isso,
  ### é feito um loop que cifra cada caracter do texto de acordo com a chave dada.
  ### O processo é feito usando a tabela ASCII como referência ('A' = 65). Todo caracter
  ### é adicionado a variavel cipher_text e como saida temos o texto criptografado.
  """
  plain_text = plain_text.upper()
  cipher_text = ""
  for char in plain_text:
    if char.isalpha():
      cipher_text += chr(((ord(char) - 65 + key) % 26) + 65)
    else:
      #caracteres especiais (nao alfabeticos) sao só adicionados na mensagem, sem troca
      cipher_text += char

  print(cipher_text)
  return cipher_text

test = "Olamundo!Tudobem?"
cifra_cesar = 3
texto_cifrado = enc_shift(test, cifra_cesar)

"""###Função de Descriptografar (Brute Force)

Na forma de resolução por meio do brute force, é necessário fazer 25 iterações, cada uma correspondendo a uma chave diferente no escopo do domínio no alfabeto. Após isso, utilizamos a chave da iteração para decriptografar a mensagem e checamos se ela é a chave correta que mostra a mensagem original.

No código, no loop interno, apenas é necessário fazer o processo contrário da criptografia. Ou seja, subtraímos o valor da chave de uma iteração ao invés de soma-lá (ou seja, "voltar" no alfabeto de uma em uma letra, até encontrar a mensagem). No exemplo dado, é percebido que, de fato, a chave era k = 3.

A abordagem tem tempo O(n). Até é plausível considerando o poder computacional atual e considerando o conjunto limitado de 26 elementos, mas pode ser resolvido de maneiras mais elegantes.
"""

def dec_brute_force(cipher_text):
  """
  ### Por brute force, o processo de decriptografar a shift cesar é simples.
  ### Só é necessário cobrir o espaço tal que |n| = 26. Assim, é garantido que
  ### todas as cifras são testastas e, logo, a mensagem será decriptografada.
  ### Como na funcao de criptografar é somada a chave, nessa, a chave é subtraida
  ### para encontrar a letra original.
  """
  plain_text = ""

  for i in range(26):
    key = i

    for char in cipher_text:
      if char.isalpha():
        plain_text += chr(((ord(char) - 65 - key) % 26) + 65)
      else:
        plain_text += char
    print(f'Chave {key} : {plain_text}')
    plain_text = ""

dec_brute_force(texto_cifrado)

"""### Função Descriptografar (Distribuição de Frequência)

Nesta forma de decriptografar, o objetivo é tentar encontrar uma maneira mais elegante e com menos gastos de recursos para decriptografar a mensagem, usando a frequencia de letras na língua ao seu favor.

Neste caso, foi utilizado a tabela de frequencia da língua portuguesa indicada nos slides, presente no seguinte link: https://www.dcc.fc.up.pt/~rvr/naulas/tabelasPT/ .

Algo interessante do português é perceber que sua gramática utiliza bastante das vogais, devido a vários motivos linguísticos, especialmente as vogais "a", "e" e "o". Segundo a tabelas, elas são disparadamente, as letras mais usadas do alfabeto, tendo uma tendência acima de 10.0. Por isso, os testes de quebra serão feitos com base nessas três vogais.

A complexidade do algoritmo depende do tamanho de caracteres mais frequentes da língua a pessoa queira pegar. No pior caso, ele pode chegar a O(n^2). Porém, considerando que esse caso é improvável pela possibilidade de quebrar a cifra sem necessitar de tantos elementos do conjunto, o algoritmo executa em O(n).
"""

#dicionario com a distribuicoes por letra para referencia
frequencia = {"A": 13.9, "B": 1.0, "C": 4.4, "D": 5.4, "E": 12.2, "F": 1.0, "G": 1.2, "H": 0.8, "I": 6.9, "J": 0.4,
              "K": 0.1, "L": 2.8, "M": 4.2, "N": 5.3, "O": 10.8, "P": 2.9, "Q": 0.9, "R": 6.9, "S": 7.9, "T": 4.9,
              "U": 4.0, "V": 1.3, "W": 0.0, "X": 0.3, "Y": 0.0, "Z": 0.4}


def dec_distribution(cipher_text):
  chars_distri = {}                 #dicionario para distribuicao de caracteres da mensagem
  letras_frequentes = [0, 4, 14]    #lista com ["A", "E", "O"] já consideradas como números para resolver a cifra

  #é feito um loop onde o resultado são as letras e suas frequencias pelo texto
  for char in cipher_text:
    if char.isalpha():
      if char in chars_distri:
        chars_distri[char] += 1
      else:
        chars_distri[char] = 1

  #é feita uma list comprehension para definir as letras que mais se repetem no texto
  temp = max(chars_distri.values())
  letras_frequentes_cifra = [letra for letra in chars_distri if chars_distri[letra] == temp]

  '''funcao para descriptografar o texto, tendo como contexto as letras mais repetidas no loop
    interno é comparado uma das letras mais repetidas no texto cifrado com 'A', 'E' e 'O' '''
  for letra in letras_frequentes_cifra:
    plain_text = ""
    keys = []                                   #lista de possíveis chaves
    for l in letras_frequentes:
      keys.append((ord(letra) - 65 - l) % 26)   #valor de uma possível chave comparando letras repetidas com 'A', 'E', 'O'
      key = (ord(letra) - 65 - l) % 26
      print(f'Caso k={key} e "{letra}" seja "{chr(l + 65)}":')

      #o texto é descriptografado com base na chave atual da iteração
      for char in cipher_text:
        if char.isalpha():
          plain_text += chr(((ord(char) - 65 - key) % 26) + 65)
        else:
          plain_text += char
      print(plain_text + "\n")
      plain_text = ""

dec_distribution(texto_cifrado)

"""## Exercício 2: Quebrando Transposition Cipher

Ex2: Quebrando Cifra por Transposição

* Elaborar o código para realizar a cifra por transposição (dica: pode escolher o método de permutação);
* Elaborar o código que quebra a cifra por transposição, descodificando por análises ao texto cifrado (CipherText-only):
  * O resultado será o texto decriptografado
  * Descrever a técnica de permutação utilizada no algoritmo para encriptar e estratégia de quebra da cifra.

### Função Encriptação (`transposition_enc`)

Nessa função de encriptar, o objetivo é transpor a mensagem e a embaralhar por meio de colunas que serão postas em ordem. Para isso é usada uma chave (k = 4).

O processo de cifra que é formado por colunas foi feito com um dicionário, em que suas chaves sao os indexes das colunas em `range(4)` (ou seja, 0-1-2-3). Os valores desse dicionário são listas que contém os caracteres que ficam alocados em cada coluna. No final, são alocados valores de letras aleatórias caso a string original não complete a última linha da matriz.

As letras são alocadas nas listas em `dict.values()` com ajuda de variáveis auxiliares:
  * **num_cols**: variável com o número total de colunas que há para essa cifra.
  
  * **aux**: uma lista auxiliar que contém os elementos que são as chaves do dicionário. Em outras palavras, o número que representa o index da coluna.

  * **i**: iterador pelo módulo no número de colunas (num_cols). Garante que cada letra seja posta em sua devida lista na chave do dicionário, já que o módulo tem um loop continuo em aux. Nesse caso, com 4 colunas, ele ira iterar até n = 3 e depois retornar para a coluna 0.
"""

import string
import random

key = 4

plain_text = "esse texto estranho"

def transposition_enc(key, plain_text):
  """"
  ### É feito um dicionario para a cifra, onde a chave do dicionario corresponde
  ### ao indíce de uma coluna. Já o valor de cada chave é uma lista que contém
  ### as letras colocadas na determinada coluna.
  """
  cipher = {}
  for i in range(key):
    cipher[i] = []

  plain_text = (plain_text.replace(" ", "")).upper()         #texto é passado para letras maiúsculas e retirado os espaços p/ facilitar criptografia
  num_cols = len(cipher)                                     #variavel auxiliar com o numero de colunas
  total_chars = num_cols * (len(plain_text) // num_cols + 1) #calculo do total de caracteres p/ preencher toda a matriz (colunas * linhas)

  while (len(plain_text) != total_chars):
    plain_text += random.choice(string.ascii_uppercase) #caso a matriz nao fique completa, é posto mais chars pseudo-aleatorios na mensagem

  aux = list(cipher.keys())                           #lista auxiliar com os indíces (chaves numericas) de cada coluna
  i = 0                                               #iterador que será usado para lista auxiliar (aux)

  '''É feito a alocação das letras com base nas colunas. A lista aux é usada
    junto com o iterador para definir em qual coluna cada letra irá ficar. '''
  for letra in plain_text:
    cipher[aux[i]].append(letra)   #letra é colocada no final da lista de uma key do dict cipher
    i = (i+1) % num_cols           #indice é mod |numero de colunas|, p/ garantir seu loop mesmo apos iterar uma vez pela lista

  #print(cipher)
  cipher_text = ""

  #loop para adicionar cada letra de cada coluna como texto cifrado
  for coluna in cipher.values():
    for letra in coluna:
      cipher_text += letra

  return cipher_text

cipher_text = transposition_enc(key, plain_text)
print(cipher_text)

"""### Função Descriptografar (`transposition_dec`)

A função de decriptografia é feita com base na quantidade de caracteres presentes no texto cifrado. Com base nisso, é possível **encontrar os múltiplos de tal número que sejam condizentes a uma possível matriz**. Assim, a configuração original das linhas e colunas necessariamente precisa ser um dos múltiplos de n (onde n é o numero de letras em cipher_text), pelo fato do algoritmo de encriptação tratar os casos simétricos.

Com base nisso, o algoritmo pega a lista de todos os múltiplos de n e testa cada um dos casos numa **transposição de matriz**. Isso é, se na cifra original uma palavra estava escrita em colunas, esse algoritmo passa os elementos para linhas com base no loop e com auxílio do mod de linhas (que, no fim, é um outro multiplo da cifra multiplicado pelo múltiplo do laço atual para resultar no tamanho da cifra).

"""

len_cipher = len(cipher_text) #numero total de letras da cifra
multiplos = [multiplo for multiplo in range(2, len_cipher) if (len_cipher % multiplo == 0)] #calculo dos multiplos de len_cipher, para determinar possiveis tamanhos da matriz

def transposition_dec(cipher_text):
  ''' Nessa função de decriptação da cifra por transposição, é pego cada um dos múltiplos da lista para tentar quebrar a cifra.
  ### Ela utiliza uma transposição de matriz para conseguir retornar os caracteres das colunas em suas posições originais, mas
  ### com todos os caracteres em ordem nas linhas (listas) da matriz, pois facilita o processo de printar a mensagem.
  ### O processo é bem sucedido graças aos módulos de'''

  for multiplo in multiplos:
    linhas = len_cipher // multiplo
    colunas = len_cipher // linhas
    matriz = [['' for _ in range(colunas)] for _ in range(linhas)] #uma nested list comprehension, onde é criada a matriz para colocação dos caracteres

    i, j = 0, 0

    for letra in cipher_text:
      ''' Caso mod(num. linhas) = 0, o iterador percorreu toda a linha da matriz de cifragem original. Isso significa que o proximo caractere
      ### deve ser a primeira letra da linha seguinte. Ou seja, é o proximo char de uma coluna original de plain_text, para o múltiplo correto.
      ### Com isso, j é iterado para que esse char seja posto na posição seguinte da lista que representa as letras em ordem original. '''

      matriz[i][j] = letra
      i = (i + 1) % linhas
      if i == 0:
        j += 1

    #print(matriz, colunas, linhas, multiplo, cipher_text, i, j)
    plain_text = "".join(["".join(coluna) for coluna in matriz])    #operação join feita para juntar os caracteres da matriz em uma string
    print(f'Para multiplo = {multiplo}, matriz[{linhas} x {colunas}], é decifrado: {plain_text}\n')


#print(len_cipher, multiplos)
transposition_dec(cipher_text)